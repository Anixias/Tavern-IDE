namespace GuildScript.Analysis.Text;

public enum TokenType
{
	EndOfFile,
	Invalid,
	WhiteSpace,
	Comment,
	
	// Operators
	Amp,
	AmpAmp,
	AmpEqual,
	AmpAmpEqual,
	Bang,
	BangEqual,
	BangDot,
	Equal,
	EqualEqual,
	LeftAngled,
	LeftAngledEqual,
	RightAngled,
	RightAngledEqual,
	Plus,
	PlusPlus,
	PlusEqual,
	Minus,
	MinusMinus,
	MinusEqual,
	Star,
	StarStar,
	StarEqual,
	StarStarEqual,
	Slash,
	SlashEqual,
	Caret,
	CaretCaret,
	CaretEqual,
	CaretCaretEqual,
	Pipe,
	PipePipe,
	PipeEqual,
	PipePipeEqual,
	Percent,
	PercentEqual,
	OpenParen,
	CloseParen,
	OpenBrace,
	CloseBrace,
	OpenSquare,
	CloseSquare,
	Comma,
	Dot,
	Semicolon,
	Colon,
	Tilde,
	LeftTriangle,
	RightTriangle,
	LeftLeftEqual,
	LeftLeftLeftEqual,
	RightRightEqual,
	RightRightRightEqual,
	LeftArrow,
	LeftArrowArrow,
	RightArrow,
	RightArrowArrow,
	Question,
	QuestionQuestion,
	QuestionEqual,
	QuestionBangEqual,
	QuestionColon,
	QuestionQuestionEqual,
	QuestionDot,
	QuestionOpenSquare,

	// Constants
	SingleConstant,
	DoubleConstant,
	Int8Constant,
	Int16Constant,
	Int32Constant,
	Int64Constant,
	UInt8Constant,
	UInt16Constant,
	UInt32Constant,
	UInt64Constant,
	StringConstant,
	CharacterConstant,
	True,
	False,
	Null,

	// Keywords
	Identifier,
	Define,
	As,
	Var,
	Async,
	Await,
	For,
	Foreach,
	In,
	Public,
	Private,
	Protected,
	Internal,
	External,
	Class,
	Struct,
	Interface,
	Enum,
	This,
	Base,
	Global,
	Template,
	Lock,
	Import,
	Export,
	Module,
	Entry,
	Final,
	Shared,
	Required,
	Prototype,
	Return,
	Void,
	Constructor,
	Destructor,
	Seal,
	Constant,
	Fixed,
	Immutable,
	Throw,
	Try,
	Catch,
	Finally,
	If,
	Else,
	While,
	Do,
	Repeat,
	New,
	Switch,
	Case,
	Default,
	Continue,
	Break,
	Get,
	Set,
	Event,
	Ref,
	Implicit,
	Explicit,

	// Built-in types
	Int8,
	UInt8,
	Int16,
	UInt16,
	Int32,
	UInt32,
	Int64,
	UInt64,
	Single,
	Double,
	Bool,
	String,
	Char,
	Object
}

public sealed class Token
{
	public TokenType Type { get; }
	public TextSpan Span { get; }
	public string Text { get; }
	public object? Value { get; }
	public string Category { get; set; } = "";
	public string ErrorMessage { get; set; } = "";
	public bool IsError { get; set; }

	public override string ToString()
	{
		return $"{Type}: '{Text.Replace("\n", "\\n").Replace("\t", "\\t")}'";
	}

	internal Token(TokenType type, TextSpan span, string text, object? value)
	{
		Type = type;
		Span = span;
		Text = text;
		Value = value;
	}
	
	public static TokenType LookupIdentifier(string identifier)
	{
		var type = identifier switch
		{
			"true"        => TokenType.True,
			"false"       => TokenType.False,
			"null"        => TokenType.Null,
			
			"define"      => TokenType.Define,
			"as"          => TokenType.As,
			"var"         => TokenType.Var,
			"async"       => TokenType.Async,
			"await"       => TokenType.Await,
			"for"         => TokenType.For,
			"foreach"     => TokenType.Foreach,
			"in"          => TokenType.In,
			"public"      => TokenType.Public,
			"private"     => TokenType.Private,
			"protected"   => TokenType.Protected,
			"internal"    => TokenType.Internal,
			"external"    => TokenType.External,
			"class"       => TokenType.Class,
			"struct"      => TokenType.Struct,
			"interface"   => TokenType.Interface,
			"enum"        => TokenType.Enum,
			"this"        => TokenType.This,
			"base"        => TokenType.Base,
			"global"      => TokenType.Global,
			"template"    => TokenType.Template,
			"lock"        => TokenType.Lock,
			"import"      => TokenType.Import,
			"export"      => TokenType.Export,
			"implicit"    => TokenType.Implicit,
			"explicit"    => TokenType.Explicit,
			"module"      => TokenType.Module,
			"entry"       => TokenType.Entry,
			"final"       => TokenType.Final,
			"shared"      => TokenType.Shared,
			"required"    => TokenType.Required,
			"prototype"   => TokenType.Prototype,
			"return"      => TokenType.Return,
			"void"        => TokenType.Void,
			"constructor" => TokenType.Constructor,
			"destructor"  => TokenType.Destructor,
			"seal"        => TokenType.Seal,
			"constant"    => TokenType.Constant,
			"fixed"       => TokenType.Fixed,
			"immutable"   => TokenType.Immutable,
			"throw"       => TokenType.Throw,
			"try"         => TokenType.Try,
			"catch"       => TokenType.Catch,
			"finally"     => TokenType.Finally,
			"if"          => TokenType.If,
			"else"        => TokenType.Else,
			"while"       => TokenType.While,
			"do"          => TokenType.Do,
			"repeat"      => TokenType.Repeat,
			"new"         => TokenType.New,
			"switch"      => TokenType.Switch,
			"case"        => TokenType.Case,
			"default"     => TokenType.Default,
			"continue"    => TokenType.Continue,
			"break"       => TokenType.Break,
			"get"         => TokenType.Get,
			"set"         => TokenType.Set,
			"event"       => TokenType.Event,
			"ref"         => TokenType.Ref,
			
			"int8"   => TokenType.Int8,
			"uint8"  => TokenType.UInt8,
			"int16"  => TokenType.Int16,
			"uint16" => TokenType.UInt16,
			"int32"  => TokenType.Int32,
			"uint32" => TokenType.UInt32,
			"int"    => TokenType.Int32,
			"uint"   => TokenType.UInt32,
			"int64"  => TokenType.Int64,
			"uint64" => TokenType.UInt64,
			"single" => TokenType.Single,
			"double" => TokenType.Double,
			"bool"   => TokenType.Bool,
			"string" => TokenType.String,
			"char"   => TokenType.Char,
			"object" => TokenType.Object,
			
			_        => TokenType.Identifier
		};
		
		return type;
	}
}